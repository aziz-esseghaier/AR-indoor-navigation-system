<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AR Navigation Dynamique</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      overflow: hidden; 
      background: #000;
      font-family: Arial, sans-serif;
    }
    #video {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: 1;
    }
    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 2;
    }
    #info {
      position: absolute;
      top: 20px;
      left: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 15px;
      border-radius: 10px;
      z-index: 3;
      font-size: 14px;
    }
    #distance {
      font-size: 28px;
      color: #0f0;
      font-weight: bold;
      margin: 5px 0;
    }
    #controls {
      position: absolute;
      bottom: 20px;
      left: 20px;
      right: 20px;
      z-index: 3;
    }
    button {
      background: #0f0;
      border: none;
      color: #000;
      padding: 15px 30px;
      border-radius: 25px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      margin: 5px;
    }
    button:active {
      transform: scale(0.95);
    }
  </style>
</head>
<body>
  <video id="video" autoplay playsinline></video>
  <canvas id="canvas"></canvas>
  
  <div id="info">
    <div><strong>üìç Navigation AR Active</strong></div>
    <div id="distance">5.0 m</div>
    <div id="instruction">Suis les fl√®ches vertes</div>
  </div>

  <div id="controls">
    <button id="addArrow">+ Ajouter Fl√®che</button>
    <button id="removeArrow">- Retirer Fl√®che</button>
  </div>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.157/build/three.module.js";

    let scene, camera, renderer;
    let arrowPath = [];
    let pathLength = 8;
    const arrowSpacing = 0.8;
    let lastCameraPos = new THREE.Vector3();
    let cameraVelocity = new THREE.Vector3();

    let deviceOrientation = { alpha: 0, beta: 0, gamma: 0 };
    let isGyroActive = false;

    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const distanceEl = document.getElementById('distance');
    const instructionEl = document.getElementById('instruction');
    const addBtn = document.getElementById('addArrow');
    const removeBtn = document.getElementById('removeArrow');

    async function init() {
      console.log('üöÄ Initialisation...');
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ 
          video: { 
            facingMode: "environment",
            width: { ideal: 1280 },
            height: { ideal: 720 }
          } 
        });
        video.srcObject = stream;
        console.log('‚úì Cam√©ra activ√©e');
      } catch (err) {
        alert("Impossible d'acc√©der √† la cam√©ra: " + err.message);
        return;
      }

      scene = new THREE.Scene();
      
      camera = new THREE.PerspectiveCamera(
        75, 
        window.innerWidth / window.innerHeight, 
        0.01, 
        100
      );
      camera.position.set(0, 0, 0);

      renderer = new THREE.WebGLRenderer({ 
        canvas: canvas,
        alpha: true,
        antialias: true
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(1, 2, 1);
      scene.add(directionalLight);

      createPath();
      requestDeviceOrientation();

      addBtn.addEventListener('click', () => {
        pathLength++;
        addArrowToPath();
        console.log(`Fl√®ches: ${pathLength}`);
      });

      removeBtn.addEventListener('click', () => {
        if (pathLength > 1) {
          pathLength--;
          removeArrowFromPath();
          console.log(`Fl√®ches: ${pathLength}`);
        }
      });

      window.addEventListener("resize", onResize);
      console.log('‚úì Initialisation termin√©e');
      animate();
    }

    function createArrow() {
      const group = new THREE.Group();
      const coneGeo = new THREE.ConeGeometry(0.12, 0.3, 3);
      const coneMat = new THREE.MeshPhongMaterial({ 
        color: 0x00ff00,
        emissive: 0x00ff00,
        emissiveIntensity: 0.3,
        flatShading: true
      });
      const cone = new THREE.Mesh(coneGeo, coneMat);
      cone.rotation.x = Math.PI / 2;
      cone.position.z = -0.15;
      group.add(cone);

      const stickGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.25, 8);
      const stick = new THREE.Mesh(stickGeo, coneMat);
      stick.rotation.x = Math.PI / 2;
      stick.position.z = 0.125;
      group.add(stick);

      group.userData = {
        time: Math.random() * Math.PI * 2,
        baseY: 0,
        pulseSpeed: 2 + Math.random()
      };

      return group;
    }

    function createPath() {
      arrowPath = [];
      for (let i = 1; i <= pathLength; i++) {
        const arrow = createArrow();
        scene.add(arrow);
        arrowPath.push(arrow);
      }
      console.log(`‚úì ${pathLength} fl√®ches cr√©√©es`);
    }

    function addArrowToPath() {
      const arrow = createArrow();
      scene.add(arrow);
      arrowPath.push(arrow);
    }

    function removeArrowFromPath() {
      if (arrowPath.length > 0) {
        const arrow = arrowPath.pop();
        scene.remove(arrow);
      }
    }

    function updatePath(deltaTime) {
      cameraVelocity.copy(camera.position).sub(lastCameraPos);
      lastCameraPos.copy(camera.position);

      const cameraDirection = new THREE.Vector3();
      camera.getWorldDirection(cameraDirection);

      arrowPath.forEach((arrow, index) => {
        const distance = (index + 1) * arrowSpacing;
        const targetPos = new THREE.Vector3()
          .copy(cameraDirection)
          .multiplyScalar(distance)
          .add(camera.position);
        targetPos.y = camera.position.y - 1.2;

        arrow.position.lerp(targetPos, 0.1);

        arrow.lookAt(
          targetPos.x + cameraDirection.x,
          targetPos.y,
          targetPos.z + cameraDirection.z
        );

        arrow.userData.time += deltaTime * arrow.userData.pulseSpeed;
        const pulse = Math.sin(arrow.userData.time) * 0.05;
        arrow.scale.setScalar(0.8 + pulse);

        arrow.position.y += Math.sin(arrow.userData.time * 2) * 0.01;
        arrow.rotation.y += deltaTime * 0.5;
      });

      if (arrowPath.length > 0) {
        const lastArrow = arrowPath[arrowPath.length - 1];
        const dist = camera.position.distanceTo(lastArrow.position);
        distanceEl.textContent = `${dist.toFixed(1)} m`;
        if (dist < 1) {
          instructionEl.textContent = 'üéâ Destination atteinte!';
        } else if (dist < 2) {
          instructionEl.textContent = 'Presque arriv√©! üéØ';
        } else {
          instructionEl.textContent = 'Suis les fl√®ches vertes üö∂';
        }
      }
    }

    function requestDeviceOrientation() {
      if (typeof DeviceOrientationEvent !== 'undefined' && 
          typeof DeviceOrientationEvent.requestPermission === 'function') {
        DeviceOrientationEvent.requestPermission()
          .then(response => {
            if (response === 'granted') {
              window.addEventListener('deviceorientation', handleOrientation);
              isGyroActive = true;
              console.log('‚úì Gyroscope activ√©');
            }
          })
          .catch(console.error);
      } else {
        window.addEventListener('deviceorientation', handleOrientation);
        isGyroActive = true;
        console.log('‚úì Gyroscope activ√©');
      }
    }

    function handleOrientation(event) {
      if (event.alpha !== null) {
        deviceOrientation.alpha = event.alpha;
        deviceOrientation.beta = event.beta;
        deviceOrientation.gamma = event.gamma;
      }
    }

    function updateCameraFromGyro() {
      if (!isGyroActive) return;
      const alpha = THREE.MathUtils.degToRad(deviceOrientation.alpha || 0);
      const beta = THREE.MathUtils.degToRad(deviceOrientation.beta || 0);
      const gamma = THREE.MathUtils.degToRad(deviceOrientation.gamma || 0);
      camera.rotation.set(beta - Math.PI / 2, alpha, -gamma, 'YXZ');
    }

    let lastTime = 0;
    function animate(time = 0) {
      requestAnimationFrame(animate);
      const deltaTime = (time - lastTime) / 1000;
      lastTime = time;
      updateCameraFromGyro();
      updatePath(deltaTime);
      renderer.render(scene, camera);
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    init();
  </script>
</body>
</html>
